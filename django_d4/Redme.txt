Зарегистрировал модели

simpleapp/admin.py

from django.contrib import admin
from .models import Category, Product

admin.site.register(Category)
admin.site.register(Product)
----------------------------------
В данный момент нам нужен дженерик ListView, который выводит список объектов
модели, используя указанный шаблон.

simpleapp/views.py

# Импортируем класс, который говорит нам о том,
# что в этом представлении мы будем выводить список объектов из БД
from django.views.generic import ListView
from .models import Product

class ProductsList(ListView):
    # Указываем модель объекты которой будем выводить
    model = Product
    # Поле, которое будет использоваться для сортировки объектов
    ordering = 'name'
    # Указываем имя шаблона, в котором будут все инструкции о том, как именно
    # пользователю должны быть показаны наши объекты
    template_name = 'products.html'
    # Это имя списка, в котором будут лежать все объекты.
    # Его надо указать, чтобы обратиться к списку объектов в html-шаблоне.
    context_object_name = 'products'

Вот так можно использовать дженерик ListView для вывода списка товаров:
 1.Создаём свой класс, который наследуется от ListView
 2.Указываем модель, из которой будем выводить данные.
 3.Указываем поле сортировки данных модели (необязательно)
 4.Записываем название шаблона.
 5.Объявляем, как хотим назвать переменную в шаблоне.
-------------------------------
Настраиваем адрес:
Для этого необходимо настроить пути в файле urls.py. При выполнении
инициализации нового приложения Django не создавал этот файл в нашей директории,
поэтому мы создадим его сами.
simpleapp/urls.py

from django.urls import path
from .views import ProductsList

urlpatterns = [
    # path - означает ПУТЬ
    # В данном случае путь ко всем товарам останется пустым
    # Т.к. объявленное представление является классом, а Django ожидает
    # функцию, надо представить этот класс в виде view.
    # Для этого вызываем метод as_view.
    path('', ProductsList.as_view()),
]
Задали ПУТЬ к нашему представлению
-----------------------------------
Вывод из БД. Для этого в главном файле urls.py в котором подключали flatpages
нужно сделать так, чтобы он автоматически включал все наши адреса из приложения
 и добавлял к нему префикс products.

django_d3/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('pages/', include('django.contrib.flatpages.urls')),
    # Делаем так, чтобы все адреса из нашего приложения (simpleapp/urls.py)
    # подключались к главному приложению с префиксом products/.
    path('products/', include('simpleapp.urls')),
]
------------------------------------
Настроил settings.py

'django.contrib.sites',
'django.contrib.flatpages',
'simpleapp'

SITE_ID = 1

'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware',

'DIRS': [os.path.join(BASE_DIR, 'templates')],
или
'DIRS': [BASE_DIR / 'templates'],

STATICFILES_DIRS = [
    BASE_DIR / "static"
]
---------------------------------------
Применил миграции

py manage.py makemigrations
py manage.py migrate

Создал супер юзера

py manage.py createsuperuser
---------------------------------------
Добавляем шаблон default.html

templates/flatpages/default.html
---------------------------------------
Добавил папку static и изменил шаблон в default.html
---------------------------------------
добавление панели в админке: для зарегистрированных пользователей
создадим файл django_d3/flatpages/admin.py

from django.contrib import admin
from django.contrib.flatpages.admin import FlatPageAdmin
from django.contrib.flatpages.models import FlatPage
from django.utils.translation import gettext_lazy as _

# Define a new FlatPageAdmin
class FlatPageAdmin(FlatPageAdmin):
    fieldsets = (
        (None, {'fields': ('url', 'title', 'content', 'sites')}),
        (_('Advanced options'), {
        'classes': ('collapse',),
        'fields': (
            'enable_comments',
            'registration_required',
            'template_name',
         ),
        }),
    )
# Re-register FlatPageAdmin
admin.site.unregister(FlatPage)
admin.site.register(FlatPage, FlatPageAdmin)

Нужно зарегистрировать новое приложение Flatpages в настройках settings.py
'fpages'
---------------------------------------
Несмотря на то, что мы видим довольно неказистый текст (пока что),всё же здесь
присутствуют наши товары.

Если переложить всё, что сделали на MVC, то получится:
1. Model - сделали модели для товаров и категорий в models.py
2. View - написали темплейт в products.html
3. Controller - настроили представление с логикой вывода списка товаров в views.py
Вот все части MVC и сложились в нашем приложении.
---------------------------------------
views.py
Фильтр цена ниже 500
class ProductsList(ListView):
    # Указываем модель объекты которой будем выводить
    # model = Product
    # Поле, которое будет использоваться для сортировки объектов
    # ordering = 'name'
    queryset = Product.objects.filter(
        price__lt=500
    )
    # Указываем имя шаблона, в котором будут все инструкции о том, как именно
    # пользователю должны быть показаны наши объекты
    template_name = 'products.html'
    # Это имя списка, в котором будут лежать все объекты.
    # Его надо указать, чтобы обратиться к списку объектов в html-шаблоне.
    context_object_name = 'products'
----
Можно добавить сортировку и по имени
queryset = Product.objects.filter(
        price__lt=900
    ).order_by('-name')
---------------------------------------
Добавил в views.py class ProductDetail(DetailView):
для отображения одного продукта
---------------------------------------
Добавляем адрес в simpleapp/urls.py.
Адрес будет немного отличаться. В него нужно добавить идентификатор товара,
который хотим получить.
    # pk - это первичный ключ товара, который будет выводиться у нас в шаблон
    # int - указывает на то, что принимаются только целочисленные значения
path('<int:pk>', ProductDetail.as_view()),
---------------------------------------
Добавляем новый шаблон для вывода одного товара по id
django_d3/templates/product.html
---------------------------------------
Подытожим
1. Добавил новое представление в view.py
2. Зарегистрировал представление в urls.py на путь, который содержит
    целочисленный идентификатор объекта.
3. Добавил новый шаблон в templates для представления.
---------------------------------------------------------
Изменил templates/products.html добавил условие если товаров нет, выводится
сообщение Товаров нет!
{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
        {% if products %}
            {{ products }}
        {% else %}
            <h2>Товаров нет!</h2>
        {% endif %}
{% endblock content %}
---------------------------------------
Это обычное условие из python:
В шаблонах выглядит так:

{% if <условие> %} # Блок HTML кода, который отобразится если условие истинно

{% elif <условие 2> %} # Блок HTML кода, который отобразится если условие 2 истинно

{% else %} # Блок HTML кода, который отобразится только если оба условия ложны

{% endif %}
---------------------------------------
Изменил templates/products.html
Создал таблицу:
{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
        {% if products %}
            <table>
                <tr>
                    <td>Название</td>
                    <td>Описание</td>
                    <td>Категория</td>
                    <td>Цена</td>
                    <td>Количество</td>
                </tr>
            </table>
        {% else %}
            <h2>Товаров нет!</h2>
        {% endif %}
{% endblock content %}
---------------------------------------
Заполнил таблицу
{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
        {% if products %}
            <table>
                 <tr>
                    <td>Название</td>
                    <td>Описание</td>
                    <td>Категория</td>
                    <td>Цена</td>
                    <td>Количество</td>
                </tr>
                {% for product in products %}
                <tr>
                    <td>{{ product.name }}</td>
                    <td>{{ product.description }}</td>
                    <td>{{ product.category.name }}</td>
                    <td>{{ product.price }}</td>
                    <td>{{ product.quantity }}</td>
                </tr>
                {% endfor %}
            </table>
        {% else %}
            <h2>Товаров нет!</h2>
        {% endif %}
{% endblock content %}
---------------------------------------
Фильтр в шаблоне: отрезает 15 символов и добавляет ...
<tr>
    <td>{{ product.name }}</td>
    <td>{{ product.description|truncatechars:15 }}</td>
    <td>{{ product.category.name }}</td>
    <td>{{ product.price }}</td>
    <td>{{ product.quantity }}</td>
</tr>
---------------------------------------
Фильтр в шаблоне: отрезает 2 слова и добавляет ...
<td>{{ product.description|truncatewords:2 }}</td>

Фильтры очень похожи на методы или функции и имеют примерно следующий синтаксис:
<переменная>|<название метода>:<аргументы>
---------------------------------------
1. Импортировал модуль datetime, чтобы получить текущую дату
2. Переопределил метод get_context_data, добавив две переменные, которые будут
доступны в шаблоне.

from datetime import datetime
class ProductsList(ListView):
# Метод get_context_data позволяет изменить набор данных,
    # который будет передан в шаблон

    def get_context_data(self, **kwargs):
        # С помощью super() обращаемся к родительским классам и вызываем у них
        # метод get_context_data с теми же аргументами.
        # В ответе должны получить словарь.
        context = super().get_context_data(**kwargs)
        # К словарю добавим текущую дату в ключ 'time_now'
        context['time_now'] = datetime.utcnow()
        # Добавим ещё одну пустую переменную,
        # чтобы на её примере рассмотреть работу ещё одного фильтра.
        context['next_sale'] = None
        return context
---------------------------------------
Добавил отображение пользователю

{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>

    # Используем переданную из представления переменную time_now и применяем
    к ней фильтр data. По назначению этот фильтр очень похож на метод
    strftime у объекта datetime в Python - вывод времени в указанном формате.

    <h3>{{ time_now|date:'M d Y'}}</h3>
    <hr>
        {% if products %}
            <table>
                 <tr>
                    <td>Название</td>
                    <td>Описание</td>
                    <td>Категория</td>
                    <td>Цена</td>
                    <td>Количество</td>
                </tr>
                {% for product in products %}
                <tr>
                    <td>{{ product.name }}</td>
                    <td>{{ product.description|truncatewords:2 }}</td>
                    <td>{{ product.category.name }}</td>
                    <td>{{ product.price }}</td>
                    <td>{{ product.quantity }}</td>
                </tr>
                {% endfor %}
            </table>
        {% else %}
            <h2>Товаров нет!</h2>
        {% endif %}
{% endblock content %}
---------------------------------------
Сообщение о распродаже:  next_sale взята из
def get_context_data(self, **kwargs): файла views.py

products.html

{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
    <h3>{{ time_now|date:'M d Y'}}</h3>
<!--        Если в переменной next_sale будет NONE,
то выведется указанный в переменной текст-->
        <h3> {{ next_sale|default_if_none:"Чуть позже сообщим о распродаже!" }}</h3>
    <hr>
        {% if products %}
---------------------------------------
При замене значения next_sale в представлении views.py на какую-нибудь строку,
будет выведено её содержимое.

def get_context_data(self, **kwargs):
        # С помощью super() обращаемся к родительским классам и вызываем у них
        # метод get_context_data с теми же аргументами.
        # В ответе должны получить словарь.
        context = super().get_context_data(**kwargs)
        # К словарю добавим текущую дату в ключ 'time_now'
        context['time_now'] = datetime.utcnow()
        # Добавим ещё одну пустую переменную,
        # чтобы на её примере рассмотреть работу ещё одного фильтра.

        context['next_sale'] = "Распродажа в среду!"

        return context
----------------
Обратите внимание, что тег default_if_none не обрабатывает пустые строки,
пустые списки и прочее. Его задача отследить только переменную None.
Для того чтобы отлавливать пустые строки, списки и другое, используется фильтр
 default, который имеет точно такой синтаксис.
---------------------------------------
Собственный фильтр

from django import template

register = template.Library()

# Регистрируем фильтр под именем currency, чтоб Django понимал,
# что это именно фильтр для шаблона, а не простая функция.

@register.filter()
def currency(value):
    """
    value: значение, к которому нуо применить фильтр
    """
    # Возвращаемое функцией значение подставится в шаблон.
    return f'{value} P'
-----------------
Декоратор register.filter() указывает Django, что нужно запомнить про
существование нового фильтра. Название фильтра по умолчанию берётся равным
названию функции,то есть в шаблоне можно писать  {{ price|currency }}.
Можно самим назвать фильтр. Например: register.filter(name='currency_rub'),
а название функции не менять, тогда в шаблоне пишем {{ price|currency_rub }}.
-------------------
Функция, которую зарегистрировали как фильтр, очень простая. Она принимает один
аргумент - переменную, с которой его используют в шаблоне. Сама функция
выполняет просто форматирование строки и сразу её возвращает. Результат этой
функции и будет подставлен в шаблоне.
----------------
После добавления файла с новыми фильтрами, нужно перезагрузить Django-сервер.
----------------
Просто взять и указать фильтр в шаблоне не получится.
Нужно подключить свои фильтры в шаблоне.
Сделать это можно с помощью указания тега {% load custom_filters %}
Где custom_filters - это название файла с нашим фильтром.
---------------------------------------
Добавили словарь со списком кодов валют и их символов, используем в функции.
Мы не увидим, ни каких ошибок насчёт того, что аргумент у фильтра есть, а мы
его не используем. Потому что указали значение по умолчанию code='rub'.

CURRENCIES_SYMBOLS = {
    'rub': 'руб',
    'usd': '$',
}

@register.filter()
def currency(value, code='rub'):
    """
    value: значение, к которому нуо применить фильтр

    """
    postfix = CURRENCIES_SYMBOLS[code]
    # Возвращаемое функцией значение подставится в шаблон.
    return f'{value} {postfix}'
---------------
Укажем в шаблоне products.html "usd"

<tr>
    <td>{{ product.name }}</td>
    <td>{{ product.description|truncatewords:2 }}</td>
    <td>{{ product.category.name }}</td>
    <td>{{ product.price|currency:"usd" }}</td>
    <td>{{ product.quantity }}</td>
</tr>
---------------------------------------
Теперь разберёмся с тегами.
Представим что текущую дату нужно вывести на множестве страниц.

simpleapp/templatetags/custom_tags.py

from datetime import datetime
from django import template

register = template.Library()

@register.simple_tag()
def current_time(format_string='%b %d %Y'):
    return datetime.utcnow().strftime(format_string)
-------------------
products.html

{% extends 'flatpages/default.html' %}
{% load custom_filters %}
<!--Подключаем новый файл с нашим тегом-->
{% load custom_tags %}

<h2>{% block title %}
    Products
    {% endblock title %}}</h2>

{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
<!--Вот так выглядело использование переменной и фильтра-->
<!--    <h3>{{ time_now|date:'M d Y'}}</h3>-->

<!--А вот так мы используем наш тег-->
    <h3>{% current_time '%b %d %Y' %}</h3>


<!--        Если в переменной next_sale будет NONE,
то выведется указанный в переменной текст-->
        <h3> {{ next_sale|default_if_none:"Чуть позже сообщим о распродаже!" }}</h3>
    <hr>
        {% if products %}
-------------------
А вот от переменной time_now, которую мы указали в представлении, теперь можно
избавиться и переиспользовать наш тег в любых шаблонах. Также как и для фильтра,
указали значение аргумента по умолчанию. Делать это необязательно, но если в
большинстве случаев будет использоваться одно и тоже значение аргумента,
то проще указать его по умолчанию.
---------------------------------------
Метод pprint:
views.py

from pprint import pprint

 def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['next_sale'] = "Распродажа в среду!"

        pprint(context)

        return context
Перезапускаем страницу и можем посмотреть в терминале что хранится
в переменной context

 pprint(id(context['object_list']))
=======================================
=======================================
Django_D4_Начало
=======================================
GET запрос
!!!!!!!!!!!!!!!
GET запрос - это HTTP- запрос в котором описано, что использован метод GET.
Например: браузер посылает HTTP- запрос с таким методом во время открытия
любого сайта для того, чтобы получить HTML-код и отрендерить его пользователю.

Кроме получения данных мы можем также создавать, изменять и удалять их.
Для этого стараются использовать другие методы - POST,DELETE и другие.
Для этого возьмём ссылку:
https://docs.djangoproject.com/en/4.0/search/?q=reqest&page=2
и разложим её на составляющие:

https - схема
:// - последовательность, которая отделяет схему от домена
docs.djangoproject.com - домен(вместо него может быть указан ip адрес)
/en/4.0/search/ - путь к ресурсу
? - знак, который отделяет параметры от ресурса
q=reqest&page=2 - параметры запроса (на английском указывают как -
                    query string или query parameters)

Нас интересуют параметры запроса. Через них можно указать номер страницы или
фильтрацию. При этом пользователь может скопировать текущий URL открытой страницы
и отправить его кому-нибудь. Так как параметр запроса хранился в URL, при
следующем открытии пользователь получит те же данные, что видел в последний раз.
Это если не было никаких изменений в БД или приложении.

Посмотрим на Пример:
https://docs.djangoproject.com/en/4.0/search/?q=reqest&page=2

В примере есть два параметра запроса с ключами q и page.
Ключ отделяется от значения знаком ( = ), а пары ключей значений - с помощью
амперсанда ( & ). Когда такой запрос поступает в Django, он раскладывает
параметры в объект класса QueryDict, который похож на Python словарь.
Главное отличие в том, что для одного ключа может быть несколько значений,
которые объединятся с списком.
>> QueryDict('a=1')  # запрос с параметром ?a=1
<QueryDit: {'a': ['1']}>
>> QueryDict('a=1&a=2&c=3')  # запрос с параметрами ?a=1&a=2&c=3
<QueryDit: {'a': ['1', '2'], 'c': ['3']}>
Этот объект, похожий на словарь, можно получить из объекта запроса, который
доступен в view.
-----------
Для примера напишем функциональную view, которая будет перемножать два переданных
числа, а если передадут не числа то выведет ошибку.
views.py функцию пишем в не класса

from django.http import HttpResponse

def multiply(request):
    number = request.GET.get('number')
    multiplier = request.GET.get('multiplier')

    try:
        result = int(number) * int(multiplier)
        html = f"<html><body>{number}*{multiplier}={result}</body></html>"
    except (ValueError, TypeError):
        html = f"<html><body>Invalid input.</body></html>"

    return HttpResponse(html)
---------------
Регистрируем view в urls.py В ОСНОВНОЙ

from django.contrib import admin
from django.urls import path, include
from simpleapp.views import multiply

urlpatterns = [
    path('admin/', admin.site.urls),
    path('pages/', include('django.contrib.flatpages.urls')),
    # Делаем так, чтобы все адреса из нашего приложения (simpleapp/urls.py)
    # подключались к главному приложению с префиксом products/.
    path('products/', include('simpleapp.urls')),
    path('multiply/', multiply),

]
--------------
Посмотрим как работают параметры GET запроса.
Откроем страницу без указания параметров. Переменные number и multiplier
будут равны None, так как их нет в словаре request.GET. При переводе к int
произойдёт TypeError.

http://127.0.0.1:8000/multiply/
# Invalid input.
---------------
Передадим значения:
http://127.0.0.1:8000/multiply/?number=3&multiplier=2
# 3*2=6
---------------
Помимо словаря с параметрами GET-запроса в объекте request есть множество
других данных: тело POST-запроса, cookie, текущий пользователь и многое другое.
Почитать здесь:
https://docs.djangoproject.com/en/4.2/ref/request-response/
---------------------------------------
Пагинация
!!!!!!!!!!!!!!!!!!!!!!!!!!
Пагинация - постраничный вывод информации на сайте.
Так как в urls.py мы регистрируем пути и view, нам не нужно прописывать
обработчик отдельно для каждой страницы. Укажем один путь а внутри view будем
смотреть, какую именно страницу или фильтрацию у нас запрашивает пользователь.
-------------
Добавим пагинацию.
views.py

class ProductsList(ListView):
    model = Product
    ordering = 'name'
    template_name = 'products.html'  # шаблон, который будет использоваться
    context_object_name = 'products'  # Переменная в шаблоне
    paginate_by = 2  # вот так можно указать количество записей на странице

------------
Запрос в браузере изменился
http://127.0.0.1:8000/products/?page=1
---------------------------------------
Добавим ссылки на другие страницы
templates/products.html

products.html

{% else %}
            <h2>Товаров нет!</h2>
        {% endif %}

Добавил вот этот код в шаблон:

        {# Добавим пагинацию на страницу #}
        {# Информация о предыдущих страницах #}
        {% if page_obj.has_previous %}
            <a href="?page=1">1</a>
            {% if page_obj.previous_page_number != 1 %}
            ...
            <a href="?page={{ page_obj.previous_page_number }}">{{ page_obj.previous_page_number }}</a>
            {% endif %}
        {% endif %}

        {# Информация о текущей странице #}
        {{ page_obj.number }}

        {# Информация о следующих страницах #}
        {% if page_obj.has_next %}
            <a href="?page={{ page_obj.next_page_number }}">{{ page_obj.next_page_number }}</a>
            {% if paginator.num_pages != page_obj.next_page_number %}
                ...
                <a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a>
            {% endif %}
        {% endif %}


{% endblock content %}
-----------------------
Разберёмся, на каком объекте из контекста построен весь наш вывод товаров.

page_obj - это объект, в котором содержится информация о текущей странице.
            Сам он приходит из класса Paginator, который содержится в ListView.
В page_obj имеем доступ к переменным:

has_previous___________существует ли предыдущая страница
previous_page_number___номер предыдущей страницы
number_________________номер текущей страницы
has_next_______________существует ли следующая страница
next_page_number_______номер следующей страницы
paginator.num_pages____объект paginator содержит информацию о количестве страниц
                        в переменной num_pages
----------------
На основе этих переменных мы вывели ссылки на другие страницы списка товаров.
Ссылки создали с помощью HTML-тега ( а ), у которого в атрибуте ( href )
указали информацию о том, на какие параметры запроса (query string) нужно заменить
данные, используя текущий путь.
HTML - страница, которая будет отдаваться пользователю, будет содержать код
вида <a href=»?page=2»>2</a>/
Можно ещё прописать путь - <a href=»/products/?page=2»>2</a>
вместе с IP и портом - <a href="http://127.0.0.1:8000/products/?page=2"»>2</a>
Однако это не удобно если решим изменить путь до страницы с /products/ на /catalog/

Для решения текущей задачи нам достаточно изменить параметры запроса.
Между открывающимся тегом <a> и закрывающим </a> у нас указывается текст,
который виден на странице как ссылка.
В данном случае указываем номер страницы.
Подробнее здесь https://htmlbook.ru/html/a
Пагинация
https://docs.djangoproject.com/en/4.0/topics/pagination/
---------------------------------------
Фильтрация
!!!!!!!!!!!!!!!!!!!
Для фильтрации данных будем использовать -
сторонний Python пакет из PyPi - django-filter.
терминал

python -m pip install django-filter
Если будут трудности то нужно указать версию фильтра
python -m pip install django-filter==21.1
Подробно здесь https://pypi.org/project/django-filter/
--------------------
Добавим "django_filters" в settings.py/ INSTALLED_APPS чтобы получить доступ
к фильтрации в приложении.
--------------------
Создаём файл simpleapp/filters.py

from django_filters import FilterSet
from .models import Product
# Создаём набор фильтров для модели Product
# FilterSet, который наследуем очень похож на Django дженерики

class ProductFilter(FilterSet):
    class Meta:
        # В Meta классе нужно указать Django модель, в которой будем
        # фильтровать записи.
        model = Product
        # В fields описываем по каким полям модели будет
        # производиться фильтрация
        fields = {
            # Поиск по названию
            'name': ['icontains'],
            # Количество товаров должно быть больше или раво
            'quantity': ['gt'],
            'price': [
                'lt',  # цена меньше или равна указанной
                'gt',  # цена больше или равна указанной
            ],
        }
--------------------
В fields содержится словарь настройки самих фильтров.
Ключами являются названия полей модели, а значениями выступают списки операторов
фильтрации. Те которые мы указываем при составлении запроса.
Product.object.filter(price_gt=10).
Подробнее здесь
https://docs.djangoproject.com/en/4.0/ref/models/querysets/#field-lookups
--------------------
Теперь созданный класс нужно использовать в представлении view для фильтрации
списка товаров.
simpleapp/views.py

from .filters import ProductFilter

Добавляем функцию в
class ProductsList(ListView):


    def get_queryset(self):
            # получаем обычный запрос
        queryset = super().get_queryset()
            # используем наш класс фильтрации
            # self.request.GET содержит объект QueryDict, который рассматривали
            # в этом юните ранее.
            # Сохраняем нашу фильтрацию в объекте класса, чтобы потом добавить в
            # контекст и использовать в шаблоне
        self.filterset = ProductFilter(self.request.GET, queryset)
            # возвращаем из функции отфильтрованный список товаров
        return self.filterset.qs

    def get_context_data(self, **kwargs):
            # С помощью super() обращаемся к родительским классам и вызываем у них
            # метод get_context_data с теми же аргументами.
            # В ответе должны получить словарь.
        context = super().get_context_data(**kwargs)
            # К словарю добавим текущую дату в ключ 'time_now'
            # context['time_now'] = datetime.utcnow()
            # Добавим ещё одну пустую переменную,
            # чтобы на её примере рассмотреть работу ещё одного фильтра.
        context['filterset'] = self.filterset

            # context['next_sale'] = "Распродажа в среду!"

        return context
-------------------
Добавляем в HTML- поля для каждого фильтра, который объявили.
Для отправки набора информации со страницы в браузере в HTML существует
специальная сущность - форма.

Форма - это набор полей, которые пользователь может заполнить и отправить
в приложение на сервер.

Мы написали, что фильтровать товары можно по нескольким полям. Пользователь
может захотеть отфильтровать товары как по одному так и по всем полям сразу.
При этом наше приложение должно получить все фильтры за один раз. То есть,
например, запрос из браузера в наше приложение должен прийти с указанием
фильтра и по названию, и по стоимости в месте, а не отдельно. Для того чтобы
собрать все указанные пользователем данные и отправить их на сервер вместе,
нам и нужна форма. В HTML - форму задают с помощью тега <form>...</form>.
Внутри неё нужно указать заголовки и поля ввода данных. Также, помимо этого, в
форме зачастую присутствует кнопка для отправки данных на сервер.
------------------
Пример того как может выглядеть форма в HTML

<form>
    <label for="nameId">Name:</label>
    <input id="nameId" type="text" name="name">
    <input type="submit" value="Отправить">
</form>
------------------
Django-filter может сгенерировать за нас все поля ввода. Нам нужно только
использовать переменную, которую ы добавили в контекст (filterset), в шаблоне
и добавить кнопку отправки формы.

products.html

 {# Добавляем форму, которая объединяет набор полей, которые будут отправляться в запросе #}
    <form action="" method="get">
        {# Переменная которую передали через контекст, может сгенерировать нам форму с полями #}
        {{ filterset.form.as_p }}
        {# Добавим кнопку отправки данных формы #}
        <input type="submit" value="Найти" />
    </form>
-------------------
чтобы фильтрация не пропадала на других страницах

custom_tags.py

@register.simple_tag(takes_context=True)
def url_replace(context, **kwargs):
    d = context['request'].GET.copy()
    for k, v in kwargs.items():
        d[k] = v
    return d.urlencode()

Параметр декоратора takes_context=True сообщает Django, что для работы тега
требуется передать контекст.
Именно тот контекст который редактировали.
context['request'].GET.copy() на позволяет скопировать все параметры текущего запроса.
Далее по указанным полям устанавливаем новые значения, которые нам передали
при использовании тега.
В конце кодируем параметры в формат, который может быть указан в строке браузера.
Не каждый символ разрешается использовать в пути и параметрах запроса.
Подробнее здесь: https://en.wikipedia.org/wiki/Percent-encoding
-------------------
Тег сделали, осталось применить его в шаблоне.
Для этого добавим в ссылки пагинации.

products.html

{% endif %}
        {# Добавим пагинацию на страницу #}
        {# Информация о предыдущих страницах #}
        {% if page_obj.has_previous %}
            {# <a href="?page=1">1</a> # было #}

{# Для каждой ссылки пагинации указываем обработку через новый тег #}
  {# Стало #}
            <a href="?{% url_replace page=1 %}">1</a>

            {% if page_obj.previous_page_number != 1 %}
                ...
                {# Было  #}
            {# <a href="?page={{ page_obj.previous_page_number }}">{{ page_obj.previous_page_number }}</a> #}

  {# Стало #}
                <a href="?{% url_replace page=page_obj.previous_page_number %}">{{ page_obj.previous_page_number }}</a>

            {% endif %}
        {% endif %}

        {# Информация о текущей странице #}
        {{ page_obj.number }}

        {# Информация о следующих страницах #}
        {% if page_obj.has_next %}
            {# Было  #}
            {# <a href="?page={{ page_obj.next_page_number }}">{{ page_obj.next_page_number }}</a> #}

  {# Стало #}
            <a href="?{% url_replace page=page_obj.next_page_number %}">{{ page_obj.next_page_number }}</a>

            {% if paginator.num_pages != page_obj.next_page_number %}
                ...
                {# Было  #}
                {# <a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a> #}

  {# Стало #}
                <a href="?{% url_replace page=page_obj.paginator.num_pages %}">{{ page_obj.paginator.num_pages }}</a>

            {% endif %}
        {% endif %}
{% endblock content %}
---------------------------------------
В данный момент в шаблонах использовали авто-генирацию HTML-кода формы.
Помимо этого, мы сами можем указать какие HTML-теги и их параметры должны
использоваться в форме.
Пример формы со строкой и кнопкой поиска.
Для этого создал файл products_form.htl  на основе products.html но изменил в
нём форму
<form action="" method="get">
        {{ filterset.form.non_field_errors }}
        {{ filterset.form.name__icontains.errors }}
        <label for="{{ filterset.form.name__icontains.id_for_label }}">Search</label>
        <input
            id="{{ filterset.form.name__icontains.id }}"
            name="{{ filterset.form.name__icontains.name }}"
            value="{{ filterset.form.name__icontains.value }}"
            class="form-control"
            >
        <input type="submit" class="mt-3 btn-primary" value="Найти" />
    </form>
----------------
Сначала с помощью {{ filterset.form.non_field_errors }} вывели все ошибки, не
относящиеся к полям формы.
После них ойдут ошибки, которые относятся к полю поиска по названию товара
{{ filterset.form.name__icontains.errors }}.
Далее составляем сами заголовки (label) и поля ввода данных формы (input).
В заголовкахуказываем для какого поля они создаются (атрибут for), а также
текст заголовка.
В поле ввода данных мы указываем больше информации:
id - идентификатор элмента, по которому заголовок будет связан с данным полем;
name - значение, которое будет ключом поля при отправки данных на сервер.
    Ключ также можно увидеть в строке браузера слева от знака =.
    Например, в URL
    http://127.0.0.1:8000/products/products_form/?name__icontains=123
    часть name__icontains и является значением атрибута name.
value - значение, которое будет отправлено на сервер. Изначально мы заполняем его,
    чтобы после отправки запроса пользователем страница загрузилась без потери
    данных, указанных им в форме. Другими словами, если мы не будем заполнять
    этот атрибут, после нажатия на кнопку ( Найти ) страница перезагрузится,
    но форма полностью очистится.
Помимо этого заполнили атрибут class в некоторых тегах, чтобы форма выглядела
немного красивее.
----------------
В views.py добавил джинерик
class ProductsForm(ListView):
----------------
В simpleapp/urels.py добавил путь
path('products_form/', ProductsForm.as_view()),

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------


---------------------------------------

---------------------------------------

---------------------------------------
Сделаем так, чтобы для работы с товарами была отдельная ссылка. Например,
просмотр всех товаров был доступен по ссылке: products/,
создание товара: product/create


