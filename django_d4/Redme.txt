Зарегистрировал модели

simpleapp/admin.py

from django.contrib import admin
from .models import Category, Product

admin.site.register(Category)
admin.site.register(Product)
----------------------------------
В данный момент нам нужен дженерик ListView, который выводит список объектов
модели, используя указанный шаблон.

simpleapp/views.py

# Импортируем класс, который говорит нам о том,
# что в этом представлении мы будем выводить список объектов из БД
from django.views.generic import ListView
from .models import Product

class ProductsList(ListView):
    # Указываем модель объекты которой будем выводить
    model = Product
    # Поле, которое будет использоваться для сортировки объектов
    ordering = 'name'
    # Указываем имя шаблона, в котором будут все инструкции о том, как именно
    # пользователю должны быть показаны наши объекты
    template_name = 'products.html'
    # Это имя списка, в котором будут лежать все объекты.
    # Его надо указать, чтобы обратиться к списку объектов в html-шаблоне.
    context_object_name = 'products'

Вот так можно использовать дженерик ListView для вывода списка товаров:
 1.Создаём свой класс, который наследуется от ListView
 2.Указываем модель, из которой будем выводить данные.
 3.Указываем поле сортировки данных модели (необязательно)
 4.Записываем название шаблона.
 5.Объявляем, как хотим назвать переменную в шаблоне.
-------------------------------
Настраиваем адрес:
Для этого необходимо настроить пути в файле urls.py. При выполнении
инициализации нового приложения Django не создавал этот файл в нашей директории,
поэтому мы создадим его сами.
simpleapp/urls.py

from django.urls import path
from .views import ProductsList

urlpatterns = [
    # path - означает ПУТЬ
    # В данном случае путь ко всем товарам останется пустым
    # Т.к. объявленное представление является классом, а Django ожидает
    # функцию, надо представить этот класс в виде view.
    # Для этого вызываем метод as_view.
    path('', ProductsList.as_view()),
]
Задали ПУТЬ к нашему представлению
-----------------------------------
Вывод из БД. Для этого в главном файле urls.py в котором подключали flatpages
нужно сделать так, чтобы он автоматически включал все наши адреса из приложения
 и добавлял к нему префикс products.

django_d3/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('pages/', include('django.contrib.flatpages.urls')),
    # Делаем так, чтобы все адреса из нашего приложения (simpleapp/urls.py)
    # подключались к главному приложению с префиксом products/.
    path('products/', include('simpleapp.urls')),
]
------------------------------------
Настроил settings.py

'django.contrib.sites',
'django.contrib.flatpages',
'simpleapp'

SITE_ID = 1

'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware',

'DIRS': [os.path.join(BASE_DIR, 'templates')],
или
'DIRS': [BASE_DIR / 'templates'],

STATICFILES_DIRS = [
    BASE_DIR / "static"
]
---------------------------------------
Применил миграции

py manage.py makemigrations
py manage.py migrate

Создал супер юзера

py manage.py createsuperuser
---------------------------------------
Добавляем шаблон default.html

templates/flatpages/default.html
---------------------------------------
Добавил папку static и изменил шаблон в default.html
---------------------------------------
добавление панели в админке: для зарегистрированных пользователей
создадим файл django_d3/flatpages/admin.py

from django.contrib import admin
from django.contrib.flatpages.admin import FlatPageAdmin
from django.contrib.flatpages.models import FlatPage
from django.utils.translation import gettext_lazy as _

# Define a new FlatPageAdmin
class FlatPageAdmin(FlatPageAdmin):
    fieldsets = (
        (None, {'fields': ('url', 'title', 'content', 'sites')}),
        (_('Advanced options'), {
        'classes': ('collapse',),
        'fields': (
            'enable_comments',
            'registration_required',
            'template_name',
         ),
        }),
    )
# Re-register FlatPageAdmin
admin.site.unregister(FlatPage)
admin.site.register(FlatPage, FlatPageAdmin)

Нужно зарегистрировать новое приложение Flatpages в настройках settings.py
'fpages'
---------------------------------------
Несмотря на то, что мы видим довольно неказистый текст (пока что),всё же здесь
присутствуют наши товары.

Если переложить всё, что сделали на MVC, то получится:
1. Model - сделали модели для товаров и категорий в models.py
2. View - написали темплейт в products.html
3. Controller - настроили представление с логикой вывода списка товаров в views.py
Вот все части MVC и сложились в нашем приложении.
---------------------------------------
views.py
Фильтр цена ниже 500
class ProductsList(ListView):
    # Указываем модель объекты которой будем выводить
    # model = Product
    # Поле, которое будет использоваться для сортировки объектов
    # ordering = 'name'
    queryset = Product.objects.filter(
        price__lt=500
    )
    # Указываем имя шаблона, в котором будут все инструкции о том, как именно
    # пользователю должны быть показаны наши объекты
    template_name = 'products.html'
    # Это имя списка, в котором будут лежать все объекты.
    # Его надо указать, чтобы обратиться к списку объектов в html-шаблоне.
    context_object_name = 'products'
----
Можно добавить сортировку и по имени
queryset = Product.objects.filter(
        price__lt=900
    ).order_by('-name')
---------------------------------------
Добавил в views.py class ProductDetail(DetailView):
для отображения одного продукта
---------------------------------------
Добавляем адрес в simpleapp/urls.py.
Адрес будет немного отличаться. В него нужно добавить идентификатор товара,
который хотим получить.
    # pk - это первичный ключ товара, который будет выводиться у нас в шаблон
    # int - указывает на то, что принимаются только целочисленные значения
path('<int:pk>', ProductDetail.as_view()),
---------------------------------------
Добавляем новый шаблон для вывода одного товара по id
django_d3/templates/product.html
---------------------------------------
Подытожим
1. Добавил новое представление в view.py
2. Зарегистрировал представление в urls.py на путь, который содержит
    целочисленный идентификатор объекта.
3. Добавил новый шаблон в templates для представления.
---------------------------------------------------------
Изменил templates/products.html добавил условие если товаров нет, выводится
сообщение Товаров нет!
{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
        {% if products %}
            {{ products }}
        {% else %}
            <h2>Товаров нет!</h2>
        {% endif %}
{% endblock content %}
---------------------------------------
Это обычное условие из python:
В шаблонах выглядит так:

{% if <условие> %} # Блок HTML кода, который отобразится если условие истинно

{% elif <условие 2> %} # Блок HTML кода, который отобразится если условие 2 истинно

{% else %} # Блок HTML кода, который отобразится только если оба условия ложны

{% endif %}
---------------------------------------
Изменил templates/products.html
Создал таблицу:
{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
        {% if products %}
            <table>
                <tr>
                    <td>Название</td>
                    <td>Описание</td>
                    <td>Категория</td>
                    <td>Цена</td>
                    <td>Количество</td>
                </tr>
            </table>
        {% else %}
            <h2>Товаров нет!</h2>
        {% endif %}
{% endblock content %}
---------------------------------------
Заполнил таблицу
{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
        {% if products %}
            <table>
                 <tr>
                    <td>Название</td>
                    <td>Описание</td>
                    <td>Категория</td>
                    <td>Цена</td>
                    <td>Количество</td>
                </tr>
                {% for product in products %}
                <tr>
                    <td>{{ product.name }}</td>
                    <td>{{ product.description }}</td>
                    <td>{{ product.category.name }}</td>
                    <td>{{ product.price }}</td>
                    <td>{{ product.quantity }}</td>
                </tr>
                {% endfor %}
            </table>
        {% else %}
            <h2>Товаров нет!</h2>
        {% endif %}
{% endblock content %}
---------------------------------------
Фильтр в шаблоне: отрезает 15 символов и добавляет ...
<tr>
    <td>{{ product.name }}</td>
    <td>{{ product.description|truncatechars:15 }}</td>
    <td>{{ product.category.name }}</td>
    <td>{{ product.price }}</td>
    <td>{{ product.quantity }}</td>
</tr>
---------------------------------------
Фильтр в шаблоне: отрезает 2 слова и добавляет ...
<td>{{ product.description|truncatewords:2 }}</td>

Фильтры очень похожи на методы или функции и имеют примерно следующий синтаксис:
<переменная>|<название метода>:<аргументы>
---------------------------------------
1. Импортировал модуль datetime, чтобы получить текущую дату
2. Переопределил метод get_context_data, добавив две переменные, которые будут
доступны в шаблоне.

from datetime import datetime
class ProductsList(ListView):
# Метод get_context_data позволяет изменить набор данных,
    # который будет передан в шаблон

    def get_context_data(self, **kwargs):
        # С помощью super() обращаемся к родительским классам и вызываем у них
        # метод get_context_data с теми же аргументами.
        # В ответе должны получить словарь.
        context = super().get_context_data(**kwargs)
        # К словарю добавим текущую дату в ключ 'time_now'
        context['time_now'] = datetime.utcnow()
        # Добавим ещё одну пустую переменную,
        # чтобы на её примере рассмотреть работу ещё одного фильтра.
        context['next_sale'] = None
        return context
---------------------------------------
Добавил отображение пользователю

{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>

    # Используем переданную из представления переменную time_now и применяем
    к ней фильтр data. По назначению этот фильтр очень похож на метод
    strftime у объекта datetime в Python - вывод времени в указанном формате.

    <h3>{{ time_now|date:'M d Y'}}</h3>
    <hr>
        {% if products %}
            <table>
                 <tr>
                    <td>Название</td>
                    <td>Описание</td>
                    <td>Категория</td>
                    <td>Цена</td>
                    <td>Количество</td>
                </tr>
                {% for product in products %}
                <tr>
                    <td>{{ product.name }}</td>
                    <td>{{ product.description|truncatewords:2 }}</td>
                    <td>{{ product.category.name }}</td>
                    <td>{{ product.price }}</td>
                    <td>{{ product.quantity }}</td>
                </tr>
                {% endfor %}
            </table>
        {% else %}
            <h2>Товаров нет!</h2>
        {% endif %}
{% endblock content %}
---------------------------------------
Сообщение о распродаже:  next_sale взята из
def get_context_data(self, **kwargs): файла views.py

products.html

{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
    <h3>{{ time_now|date:'M d Y'}}</h3>
<!--        Если в переменной next_sale будет NONE,
то выведется указанный в переменной текст-->
        <h3> {{ next_sale|default_if_none:"Чуть позже сообщим о распродаже!" }}</h3>
    <hr>
        {% if products %}
---------------------------------------
При замене значения next_sale в представлении views.py на какую-нибудь строку,
будет выведено её содержимое.

def get_context_data(self, **kwargs):
        # С помощью super() обращаемся к родительским классам и вызываем у них
        # метод get_context_data с теми же аргументами.
        # В ответе должны получить словарь.
        context = super().get_context_data(**kwargs)
        # К словарю добавим текущую дату в ключ 'time_now'
        context['time_now'] = datetime.utcnow()
        # Добавим ещё одну пустую переменную,
        # чтобы на её примере рассмотреть работу ещё одного фильтра.

        context['next_sale'] = "Распродажа в среду!"

        return context
----------------
Обратите внимание, что тег default_if_none не обрабатывает пустые строки,
пустые списки и прочее. Его задача отследить только переменную None.
Для того чтобы отлавливать пустые строки, списки и другое, используется фильтр
 default, который имеет точно такой синтаксис.
---------------------------------------
Собственный фильтр

from django import template

register = template.Library()

# Регистрируем фильтр под именем currency, чтоб Django понимал,
# что это именно фильтр для шаблона, а не простая функция.

@register.filter()
def currency(value):
    """
    value: значение, к которому нуо применить фильтр
    """
    # Возвращаемое функцией значение подставится в шаблон.
    return f'{value} P'
-----------------
Декоратор register.filter() указывает Django, что нужно запомнить про
существование нового фильтра. Название фильтра по умолчанию берётся равным
названию функции,то есть в шаблоне можно писать  {{ price|currency }}.
Можно самим назвать фильтр. Например: register.filter(name='currency_rub'),
а название функции не менять, тогда в шаблоне пишем {{ price|currency_rub }}.
-------------------
Функция, которую зарегистрировали как фильтр, очень простая. Она принимает один
аргумент - переменную, с которой его используют в шаблоне. Сама функция
выполняет просто форматирование строки и сразу её возвращает. Результат этой
функции и будет подставлен в шаблоне.
----------------
После добавления файла с новыми фильтрами, нужно перезагрузить Django-сервер.
----------------
Просто взять и указать фильтр в шаблоне не получится.
Нужно подключить свои фильтры в шаблоне.
Сделать это можно с помощью указания тега {% load custom_filters %}
Где custom_filters - это название файла с нашим фильтром.
---------------------------------------
Добавили словарь со списком кодов валют и их символов, используем в функции.
Мы не увидим, ни каких ошибок насчёт того, что аргумент у фильтра есть, а мы
его не используем. Потому что указали значение по умолчанию code='rub'.

CURRENCIES_SYMBOLS = {
    'rub': 'руб',
    'usd': '$',
}

@register.filter()
def currency(value, code='rub'):
    """
    value: значение, к которому нуо применить фильтр

    """
    postfix = CURRENCIES_SYMBOLS[code]
    # Возвращаемое функцией значение подставится в шаблон.
    return f'{value} {postfix}'
---------------
Укажем в шаблоне products.html "usd"

<tr>
    <td>{{ product.name }}</td>
    <td>{{ product.description|truncatewords:2 }}</td>
    <td>{{ product.category.name }}</td>
    <td>{{ product.price|currency:"usd" }}</td>
    <td>{{ product.quantity }}</td>
</tr>
---------------------------------------
Теперь разберёмся с тегами.
Представим что текущую дату нужно вывести на множестве страниц.

simpleapp/templatetags/custom_tags.py

from datetime import datetime
from django import template

register = template.Library()

@register.simple_tag()
def current_time(format_string='%b %d %Y'):
    return datetime.utcnow().strftime(format_string)
-------------------
products.html

{% extends 'flatpages/default.html' %}
{% load custom_filters %}
<!--Подключаем новый файл с нашим тегом-->
{% load custom_tags %}

<h2>{% block title %}
    Products
    {% endblock title %}}</h2>

{% block content %}
    <hr>
    <h3>products.html</h3>
    <hr>
    <h1>Все товары</h1>
<!--Вот так выглядело использование переменной и фильтра-->
<!--    <h3>{{ time_now|date:'M d Y'}}</h3>-->

<!--А вот так мы используем наш тег-->
    <h3>{% current_time '%b %d %Y' %}</h3>


<!--        Если в переменной next_sale будет NONE,
то выведется указанный в переменной текст-->
        <h3> {{ next_sale|default_if_none:"Чуть позже сообщим о распродаже!" }}</h3>
    <hr>
        {% if products %}
-------------------
А вот от переменной time_now, которую мы указали в представлении, теперь можно
избавиться и переиспользовать наш тег в любых шаблонах. Также как и для фильтра,
указали значение аргумента по умолчанию. Делать это необязательно, но если в
большинстве случаев будет использоваться одно и тоже значение аргумента,
то проще указать его по умолчанию.
---------------------------------------
Метод pprint:
views.py

from pprint import pprint

 def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['next_sale'] = "Распродажа в среду!"

        pprint(context)

        return context
Перезапускаем страницу и можем посмотреть в терминале что хранится
в переменной context

 pprint(id(context['object_list']))
=======================================
=======================================
Django_D4_Начало
=======================================
GET запрос
!!!!!!!!!!!!!!!
GET запрос - это HTTP- запрос в котором описано, что использован метод GET.
Например: браузер посылает HTTP- запрос с таким методом во время открытия
любого сайта для того, чтобы получить HTML-код и отрендерить его пользователю.

Кроме получения данных мы можем также создавать, изменять и удалять их.
Для этого стараются использовать другие методы - POST,DELETE и другие.
Для этого возьмём ссылку:
https://docs.djangoproject.com/en/4.0/search/?q=reqest&page=2
и разложим её на составляющие:

https - схема
:// - последовательность, которая отделяет схему от домена
docs.djangoproject.com - домен(вместо него может быть указан ip адрес)
/en/4.0/search/ - путь к ресурсу
? - знак, который отделяет параметры от ресурса
q=reqest&page=2 - параметры запроса (на английском указывают как -
                    query string или query parameters)

Нас интересуют параметры запроса. Через них можно указать номер страницы или
фильтрацию. При этом пользователь может скопировать текущий URL открытой страницы
и отправить его кому-нибудь. Так как параметр запроса хранился в URL, при
следующем открытии пользователь получит те же данные, что видел в последний раз.
Это если не было никаких изменений в БД или приложении.

Посмотрим на Пример:
https://docs.djangoproject.com/en/4.0/search/?q=reqest&page=2

В примере есть два параметра запроса с ключами q и page.
Ключ отделяется от значения знаком ( = ), а пары ключей значений - с помощью
амперсанда ( & ). Когда такой запрос поступает в Django, он раскладывает
параметры в объект класса QueryDict, который похож на Python словарь.
Главное отличие в том, что для одного ключа может быть несколько значений,
которые объединятся с списком.
>> QueryDict('a=1')  # запрос с параметром ?a=1
<QueryDit: {'a': ['1']}>
>> QueryDict('a=1&a=2&c=3')  # запрос с параметрами ?a=1&a=2&c=3
<QueryDit: {'a': ['1', '2'], 'c': ['3']}>
Этот объект, похожий на словарь, можно получить из объекта запроса, который
доступен в view.
-----------
Для примера напишем функциональную view, которая будет перемножать два переданных
числа, а если передадут не числа то выведет ошибку.
views.py функцию пишем в не класса

from django.http import HttpResponse

def multiply(request):
    number = request.GET.get('number')
    multiplier = request.GET.get('multiplier')

    try:
        result = int(number) * int(multiplier)
        html = f"<html><body>{number}*{multiplier}={result}</body></html>"
    except (ValueError, TypeError):
        html = f"<html><body>Invalid input.</body></html>"

    return HttpResponse(html)
---------------
Регистрируем view в urls.py В ОСНОВНОЙ

from django.contrib import admin
from django.urls import path, include
from simpleapp.views import multiply

urlpatterns = [
    path('admin/', admin.site.urls),
    path('pages/', include('django.contrib.flatpages.urls')),
    # Делаем так, чтобы все адреса из нашего приложения (simpleapp/urls.py)
    # подключались к главному приложению с префиксом products/.
    path('products/', include('simpleapp.urls')),
    path('multiply/', multiply),

]
--------------
Посмотрим как работают параметры GET запроса.
Откроем страницу без указания параметров. Переменные number и multiplier
будут равны None, так как их нет в словаре request.GET. При переводе к int
произойдёт TypeError.

http://127.0.0.1:8000/multiply/
# Invalid input.
---------------
Передадим значения:
http://127.0.0.1:8000/multiply/?number=3&multiplier=2
# 3*2=6
---------------
Помимо словаря с параметрами GET-запроса в объекте request есть множество
других данных: тело POST-запроса, cookie, текущий пользователь и многое другое.
Почитать здесь:
https://docs.djangoproject.com/en/4.2/ref/request-response/
---------------------------------------
Пагинация
!!!!!!!!!!!!!!!!!!!!!!!!!!
Пагинация - постраничный вывод информации на сайте.
Так как в urls.py мы регистрируем пути и view, нам не нужно прописывать
обработчик отдельно для каждой страницы. Укажем один путь а внутри view будем
смотреть, какую именно страницу или фильтрацию у нас запрашивает пользователь.
-------------
Добавим пагинацию.
views.py

class ProductsList(ListView):
    model = Product
    ordering = 'name'
    template_name = 'products.html'  # шаблон, который будет использоваться
    context_object_name = 'products'  # Переменная в шаблоне
    paginate_by = 2  # вот так можно указать количество записей на странице

------------
Запрос в браузере изменился
http://127.0.0.1:8000/products/?page=1
---------------------------------------
Добавим ссылки на другие страницы
templates/products.html

products.html

{% else %}
            <h2>Товаров нет!</h2>
        {% endif %}

Добавил вот этот код в шаблон:

        {# Добавим пагинацию на страницу #}
        {# Информация о предыдущих страницах #}
        {% if page_obj.has_previous %}
            <a href="?page=1">1</a>
            {% if page_obj.previous_page_number != 1 %}
            ...
            <a href="?page={{ page_obj.previous_page_number }}">{{ page_obj.previous_page_number }}</a>
            {% endif %}
        {% endif %}

        {# Информация о текущей странице #}
        {{ page_obj.number }}

        {# Информация о следующих страницах #}
        {% if page_obj.has_next %}
            <a href="?page={{ page_obj.next_page_number }}">{{ page_obj.next_page_number }}</a>
            {% if paginator.num_pages != page_obj.next_page_number %}
                ...
                <a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a>
            {% endif %}
        {% endif %}


{% endblock content %}
-----------------------
Разберёмся, на каком объекте из контекста построен весь наш вывод товаров.

page_obj - это объект, в котором содержится информация о текущей странице.
            Сам он приходит из класса Paginator, который содержится в ListView.
В page_obj имеем доступ к переменным:

has_previous___________существует ли предыдущая страница
previous_page_number___номер предыдущей страницы
number_________________номер текущей страницы
has_next_______________существует ли следующая страница
next_page_number_______номер следующей страницы
paginator.num_pages____объект paginator содержит информацию о количестве страниц
                        в переменной num_pages
----------------
На основе этих переменных мы вывели ссылки на другие страницы списка товаров.
Ссылки создали с помощью HTML-тега ( а ), у которого в атрибуте ( href )
указали информацию о том, на какие параметры запроса (query string) нужно заменить
данные, используя текущий путь.
HTML - страница, которая будет отдаваться пользователю, будет содержать код
вида <a href=»?page=2»>2</a>/
Можно ещё прописать путь - <a href=»/products/?page=2»>2</a>
вместе с IP и портом - <a href="http://127.0.0.1:8000/products/?page=2"»>2</a>
Однако это не удобно если решим изменить путь до страницы с /products/ на /catalog/

Для решения текущей задачи нам достаточно изменить параметры запроса.
Между открывающимся тегом <a> и закрывающим </a> у нас указывается текст,
который виден на странице как ссылка.
В данном случае указываем номер страницы.
Подробнее здесь https://htmlbook.ru/html/a
Пагинация
https://docs.djangoproject.com/en/4.0/topics/pagination/
---------------------------------------
Фильтрация
!!!!!!!!!!!!!!!!!!!
Для фильтрации данных будем использовать -
сторонний Python пакет из PyPi - django-filter.
терминал

python -m pip install django-filter
Если будут трудности то нужно указать версию фильтра
python -m pip install django-filter==21.1
Подробно здесь https://pypi.org/project/django-filter/
--------------------
Добавим "django_filters" в settings.py/ INSTALLED_APPS чтобы получить доступ
к фильтрации в приложении.
--------------------
Создаём файл simpleapp/filters.py

from django_filters import FilterSet
from .models import Product
# Создаём набор фильтров для модели Product
# FilterSet, который наследуем очень похож на Django дженерики

class ProductFilter(FilterSet):
    class Meta:
        # В Meta классе нужно указать Django модель, в которой будем
        # фильтровать записи.
        model = Product
        # В fields описываем по каким полям модели будет
        # производиться фильтрация
        fields = {
            # Поиск по названию
            'name': ['icontains'],
            # Количество товаров должно быть больше или раво
            'quantity': ['gt'],
            'price': [
                'lt',  # цена меньше или равна указанной
                'gt',  # цена больше или равна указанной
            ],
        }
--------------------
В fields содержится словарь настройки самих фильтров.
Ключами являются названия полей модели, а значениями выступают списки операторов
фильтрации. Те которые мы указываем при составлении запроса.
Product.object.filter(price_gt=10).
Подробнее здесь
https://docs.djangoproject.com/en/4.0/ref/models/querysets/#field-lookups
--------------------
Теперь созданный класс нужно использовать в представлении view для фильтрации
списка товаров.
simpleapp/views.py

from .filters import ProductFilter

Добавляем функцию в
class ProductsList(ListView):


    def get_queryset(self):
            # получаем обычный запрос
        queryset = super().get_queryset()
            # используем наш класс фильтрации
            # self.request.GET содержит объект QueryDict, который рассматривали
            # в этом юните ранее.
            # Сохраняем нашу фильтрацию в объекте класса, чтобы потом добавить в
            # контекст и использовать в шаблоне
        self.filterset = ProductFilter(self.request.GET, queryset)
            # возвращаем из функции отфильтрованный список товаров
        return self.filterset.qs

    def get_context_data(self, **kwargs):
            # С помощью super() обращаемся к родительским классам и вызываем у них
            # метод get_context_data с теми же аргументами.
            # В ответе должны получить словарь.
        context = super().get_context_data(**kwargs)
            # К словарю добавим текущую дату в ключ 'time_now'
            # context['time_now'] = datetime.utcnow()
            # Добавим ещё одну пустую переменную,
            # чтобы на её примере рассмотреть работу ещё одного фильтра.
        context['filterset'] = self.filterset

            # context['next_sale'] = "Распродажа в среду!"

        return context
-------------------
Добавляем в HTML- поля для каждого фильтра, который объявили.
Для отправки набора информации со страницы в браузере в HTML существует
специальная сущность - форма.

Форма - это набор полей, которые пользователь может заполнить и отправить
в приложение на сервер.

Мы написали, что фильтровать товары можно по нескольким полям. Пользователь
может захотеть отфильтровать товары как по одному так и по всем полям сразу.
При этом наше приложение должно получить все фильтры за один раз. То есть,
например, запрос из браузера в наше приложение должен прийти с указанием
фильтра и по названию, и по стоимости в месте, а не отдельно. Для того чтобы
собрать все указанные пользователем данные и отправить их на сервер вместе,
нам и нужна форма. В HTML - форму задают с помощью тега <form>...</form>.
Внутри неё нужно указать заголовки и поля ввода данных. Также, помимо этого, в
форме зачастую присутствует кнопка для отправки данных на сервер.
------------------
Пример того как может выглядеть форма в HTML

<form>
    <label for="nameId">Name:</label>
    <input id="nameId" type="text" name="name">
    <input type="submit" value="Отправить">
</form>
------------------
Django-filter может сгенерировать за нас все поля ввода. Нам нужно только
использовать переменную, которую ы добавили в контекст (filterset), в шаблоне
и добавить кнопку отправки формы.

products.html

 {# Добавляем форму, которая объединяет набор полей, которые будут отправляться в запросе #}
    <form action="" method="get">
        {# Переменная которую передали через контекст, может сгенерировать нам форму с полями #}
        {{ filterset.form.as_p }}
        {# Добавим кнопку отправки данных формы #}
        <input type="submit" value="Найти" />
    </form>
-------------------
чтобы фильтрация не пропадала на других страницах

custom_tags.py

@register.simple_tag(takes_context=True)
def url_replace(context, **kwargs):
    d = context['request'].GET.copy()
    for k, v in kwargs.items():
        d[k] = v
    return d.urlencode()

Параметр декоратора takes_context=True сообщает Django, что для работы тега
требуется передать контекст.
Именно тот контекст который редактировали.
context['request'].GET.copy() нам позволяет скопировать все параметры текущего
запроса.
Далее по указанным полям устанавливаем новые значения, которые нам передали
при использовании тега.
В конце кодируем параметры в формат, который может быть указан в строке браузера.
Не каждый символ разрешается использовать в пути и параметрах запроса.
Подробнее здесь: https://en.wikipedia.org/wiki/Percent-encoding
-------------------
Тег сделали, осталось применить его в шаблоне.
Для этого добавим в ссылки пагинации.

products.html

{% endif %}
        {# Добавим пагинацию на страницу #}
        {# Информация о предыдущих страницах #}
        {% if page_obj.has_previous %}
            {# <a href="?page=1">1</a> # было #}

{# Для каждой ссылки пагинации указываем обработку через новый тег #}
  {# Стало #}
            <a href="?{% url_replace page=1 %}">1</a>

            {% if page_obj.previous_page_number != 1 %}
                ...
                {# Было  #}
            {# <a href="?page={{ page_obj.previous_page_number }}">{{ page_obj.previous_page_number }}</a> #}

  {# Стало #}
                <a href="?{% url_replace page=page_obj.previous_page_number %}">{{ page_obj.previous_page_number }}</a>

            {% endif %}
        {% endif %}

        {# Информация о текущей странице #}
        {{ page_obj.number }}

        {# Информация о следующих страницах #}
        {% if page_obj.has_next %}
            {# Было  #}
            {# <a href="?page={{ page_obj.next_page_number }}">{{ page_obj.next_page_number }}</a> #}

  {# Стало #}
            <a href="?{% url_replace page=page_obj.next_page_number %}">{{ page_obj.next_page_number }}</a>

            {% if paginator.num_pages != page_obj.next_page_number %}
                ...
                {# Было  #}
                {# <a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a> #}

  {# Стало #}
                <a href="?{% url_replace page=page_obj.paginator.num_pages %}">{{ page_obj.paginator.num_pages }}</a>

            {% endif %}
        {% endif %}
{% endblock content %}
---------------------------------------
В данный момент в шаблонах использовали авто-генирацию HTML-кода формы.
Помимо этого, мы сами можем указать какие HTML-теги и их параметры должны
использоваться в форме.
Пример формы со строкой и кнопкой поиска.
Для этого создал файл products_form.htl  на основе products.html но изменил в
нём форму
<form action="" method="get">
        {{ filterset.form.non_field_errors }}
        {{ filterset.form.name__icontains.errors }}
        <label for="{{ filterset.form.name__icontains.id_for_label }}">Search</label>
        <input
            id="{{ filterset.form.name__icontains.id }}"
            name="{{ filterset.form.name__icontains.name }}"
            value="{{ filterset.form.name__icontains.value }}"
            class="form-control"
            >
        <input type="submit" class="mt-3 btn-primary" value="Найти" />
    </form>
----------------
Сначала с помощью {{ filterset.form.non_field_errors }} вывели все ошибки, не
относящиеся к полям формы.
После них ойдут ошибки, которые относятся к полю поиска по названию товара
{{ filterset.form.name__icontains.errors }}.
Далее составляем сами заголовки (label) и поля ввода данных формы (input).
В заголовкахуказываем для какого поля они создаются (атрибут for), а также
текст заголовка.
В поле ввода данных мы указываем больше информации:
id - идентификатор элмента, по которому заголовок будет связан с данным полем;
name - значение, которое будет ключом поля при отправки данных на сервер.
    Ключ также можно увидеть в строке браузера слева от знака =.
    Например, в URL
    http://127.0.0.1:8000/products/products_form/?name__icontains=123
    часть name__icontains и является значением атрибута name.
value - значение, которое будет отправлено на сервер. Изначально мы заполняем его,
    чтобы после отправки запроса пользователем страница загрузилась без потери
    данных, указанных им в форме. Другими словами, если мы не будем заполнять
    этот атрибут, после нажатия на кнопку ( Найти ) страница перезагрузится,
    но форма полностью очистится.
Помимо этого заполнили атрибут class в некоторых тегах, чтобы форма выглядела
немного красивее.
----------------
В views.py добавил джинерик
class ProductsForm(ListView):
----------------
В simpleapp/urels.py добавил путь
path('products_form/', ProductsForm.as_view()),
---------------------------------------
===============================================================================
D_4
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

POST - запросы

!!!!!!!!!!!!!!!!!!!!!!!
Для передачи данных  POST - запросах используется тело запроса.
В самом URL вы его не увилите. Его можно посмотреть с помощью Chrome DevToos.

Рассмотрим как мог выглядеть запрос на -СОЗДАНИЕ ТОВАРА-

POST/products/create HTTP/1.1
Host: 127.0.0.1
Content-Type:application/x-www-form-urlencoded
Content-Length: 16
name=PythonBook&price=1000

Сначала указываем метод запроса (POST), путь (/products/create) и протокол (HTTP/1.1)
Host - адрес сервера на который отсылается запрос.
Content-Type - тип данных в теле запроса.
Content-Length - длина тела запроса.
Далее идёт само тело запроса.В нашем случае данные закодированы таким же образом,
как в параметрах GET- запроса.
GET - запросы используются, как правило, для того, чтобы получить какую-то
информацию с сервера, в то время как POST- запросы нужны для загрузки информации
на сервер. Хотя HTML- формы, должны быть написаны в HTML- файлах, Django
предоставляет нам инструменты генерации форм. В предыдущем юните мы пробовали
использовать формы. Тогда форму сгенерировал пакет django-filter.
Теперь создадим свою форму для модели товаров.
----------------
Создадим файл simpleapp/forms.py

from django import forms
from .models import Product


class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = '__all__'

Создали собственный класс формы, наследуя ModelForm. Данный стандартный класс
позволяет создавать формы на основе моделей.
Саму модель прописываем в Meta классе в поле model=Product.
fields = '__all__' - означает что нужно из модели взять все поля,
кроме первичного ключа (его мы не должны редактировать).
В место этого мы могли и сами перечислить всеполя в ручную.
fields = [
    'name',
    'description',
    'quentity',
    'category',
    'price'
    ]
СОВЕТ:
       Для рабочих проектов лучше перечислять поля самостоятельно, чтобы не
       было ситуации, что добавили новое поле в модель, которое нельзя
       редактировать пользователям.
Как мы расположили поля в списке, в таком порядке они и будут выведены на
странице.
Это значит что мы сможем удобнее и логичнее вывести данные для заполнения.
----------------
Перейдём в shell

pyton manage.py shell

>>> from simpleapp.forms import ProductForm

>>> f = ProductForm({'name': 'test', 'category': '1', 'price': 42, 'description': '', 'quantit
y': 1})
>>> f.is_valid()
False
Djano говорит нам что форма не валидна ( тоесть есть ошибка в заполнении )
>>> f.errors
{'description': ['This field is required.']} # не добавили описание

>>> f = ProductForm({'name': 'test', 'category': '1', 'price': 42, 'description': 'terof', 'qu
antity': 1})
>>> f.is_valid()
True

Для доступа к обработанным данным существует поле cleaned_data
>>> f.cleaned_data
{'name': 'test', 'description': 'terof', 'quantity': 1, 'category': <Category: Колбаса>, 'pric
e': 42.0}
Мы видим, что вместо id категории подставился объект модели,
а ена теперь имеет тип float
Если нам передадут в форму лишние данные, то при обработке они будут пропущены
и не возникнет никаких ошибок.
Добавим в форму лишний ключ 'extra_field'

f = ProductForm({'name': 'test', 'category': '1', 'price': 42,
'description': 'terof', 'quantity': 1, 'extra_field': 123})

>>> f.is_valid()
True
>>> f.cleaned_data
{'name': 'test', 'description': 'terof', 'quantity': 1, 'category': <Category: Колбаса>, 'pric
e': 42.0}

Если мы напечатаем объект формы, то увидим сгенерированный HTML.
Именно этот HTML- код будет добавдяться в шаблон, когда мы будем использовать
в нём формы.

>>> print(f)
<tr>
    <th><label for="id_name">Name:</label></th>
    <td>
      <input type="text" name="name" value="test" maxlength="50" required id="id_name">
   </td>
  </tr>
  <tr>
    <th><label for="id_description">Description:</label></th>
    <td>
      <textarea name="description" cols="40" rows="10" required id="id_description">
terof</textarea>
    </td>
  </tr>
  <tr>
    <th><label for="id_quantity">Quantity:</label></th>
    <td>
      <input type="number" name="quantity" value="1" required id="id_quantity">
    </td>
  </tr>
  <tr>
    <th><label for="id_category">Category:</label></th>
    <td>
      <select name="category" required id="id_category">
  <option value="">---------</option>
  <option value="1" selected>Колбаса</option>
  <option value="2">Велосипеды</option>
</select>
    </td>
  </tr>
  <tr>
    <th><label for="id_price">Price:</label></th>
    <td>
      <input type="number" name="price" value="42" step="any" required id="id_price">
    </td>
  </tr>
В полях HTML - формы уже проставлены значения из нашей: input c name="name"
имеет value="test", select name="category" в теге с option value="1" имеет
selected и так далее.

Помимо того, что форма может быть авто-сгенерирована на основе какой-либо модели,
Django позволяет создавать их, просто указывая поля. Этот метод похож на то как
мы описывали модели.
Для этого используется тело класса формы, а не вложенный в него Мета-класс.
Вот так выглядело бы создание формы при написании его без Мета-класса.
class ProductForm(forms.Form):
    name = forms.CharField(label='Name')
    description = forms.CharField(label='Description')
    quentity = forms.IntegerField(label='Quentity')
    category = forms.ModelChoiceField(label='Category',
    queryset='Category.objects.all(),)
    price = forms.FloatField(label='Price')

В ближайее время нам не понадобится эта возможность Django.
Подробнее здесь: https://docs.djangoproject.com/en/4.0/ref/forms/fields/
---------------------------------------
Бывают ситуации, когда мы не хотим записывать в БД всё, что присылают нам
пользователи. Например в прошлом юните мы создали цензурный фильтр который убирал
нецензурные слова. В реальной задаче мы могли бы вообще запретить сохранять
не нужные статьи (новости). В таком случае нам поможет проверка данных, которые
пользователь присылает нам в форму.
-------------------
Добавим ограничения - описание товара должно быть не менее 20 имволов и не должно
совпадать с названием товара.
Читать  документации здесь:
https://docs.djangoproject.com/en/4.0/ref/forms/api/#django.forms.Form.clean
В разделе про формы есть пункт, в котором указано, что, если мы хотим сделать
свои собственные проверки, нам нужно переопределить метод clean в форме.
Добавим проверкудлины поля description/

simpleapp/forms.py

from django import forms
from django.core.exceptions import ValidationError
from .models import Product

class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = [
            'name',
            'description',
            'category',
            'price',
            'quantity',
        ]

    def clean(self):
        cleaned_data = super().clean()
        description = cleaned_data.get("description")
        if description is not None and len(description) < 20:
            raise ValidationError({
                "description": "Описание не может быть меньше 20 символов."
            })
        return cleaned_data
----------------
Переопределили метод clean и реализовали в нём проверку.
Вызываем в методе clean из родительского класса и
сохоаняем данные формы в clean_data.
Получаем description и проверяем его значение. Если значение не проходит по
длине, то вызываем ошибку. В ошибке указываем название поля формы и текст оибки.
Если проверка прошла успешно, возвращаем из функции проверенные данные формы.
----------------
Идём в Shell

from simpleapp.forms import ProductForm

>>> f = ProductForm({'name': 'test', 'category': 1, 'price': 42, 'description': 'test', 'quant
ity': 1})
>>> f.errors
{'description': ['Описание не может быть меньше 20 символов.']}

Проверка работает.
-------------------
Проверка данных в двух полях:
simpleapp/forms.py

    def clean(self):
        cleaned_data = super().clean()
        description = cleaned_data.get("description")
        if description is not None and len(description) < 20:
            raise ValidationError({
                "description": "Описание не может быть меньше 20 символов."
            })

        name = cleaned_data.get("name")
        if name == description:
            raise ValidationError(
                "Описание не должно быть идентично названию."
            )

        return cleaned_data
Добавили поле name для проверки.
--------------
Идём в Shell

>>> from simpleapp.forms import ProductForm
>>> f = ProductForm({'name': '12345678901234567890', 'category': '1', 'price': 42, 'descriptio
n': '12345678901234567890', 'quantity': 1})
>>> f.errors
{'__all__': ['Описание не должно быть идентично названию.']}

Так как мы не указали поле при создании ошибки, Django добавил ключ __all__,
который сообщает, что ошибка относится ко всей форме, а не к определённому полю.
---------------------------------------
Другой механизм валидации данных

from django import forms
from django.core.exceptions import ValidationError
from .models import Product


class ProductForm(forms.ModelForm):
    description = forms.CharField(min_length=20) # указали минимальную длину

    class Meta:
        model = Product
        fields = [
            'name',
            'description',
            'category',
            'price',
            'quantity',
        ]

    def clean(self):
        cleaned_data = super().clean()
        name = cleaned_data.get("name")
        description = cleaned_data.get("description")

        if name == description:
            raise ValidationError(
                "Описание не должно быть идентично названию."
            )

        return cleaned_data

Убрали проверку на длину описания из метода, добавили поле в саму форму и в этом
поле уже поставили ограничение на минимальную длину строки.
---------------
Для проверки работы идём в Shell

>>> from simpleapp.forms import ProductForm
>>> f = ProductForm({'name': 'test', 'category': 1, 'price': 42, 'description': 'test', 'quant
ity': 1})
>>> f.errors
{'description': ['Ensure this value has at least 20 characters (it has 4).']}

>>> f = ProductForm({'name': 'test', 'category': 1, 'price': 42, 'description': '1234567890123
4567890', 'quantity': 1})
>>> f.errors
{}
------------------
Всё хорошо. Валидация работает. Однако мы не сможем внести на уровень полей формы
совместную проверку текста в названии и описании.По этому для каждой задачи нужно
использовать свой инструмент.
------------------
Третий способ проверки валидации данных.
Позволяет проверить с помощью функции данные одного конкретного поля.
Ранее с помощью функции мы получали доступ к проверке всех полей вместе.
Например так можно проверить, написано ли название товара с заглавной буквы.

simpleapp/forms.py

def clean_name(self):
      name = self.cleaned_data["name"]
      if name[0].islower():
          raise ValidationError(
              "Название должно начинаться с заглавной буквы."
          )
      return name
-----------------
Выбирайте соответствующий способ валидации данных, исходя из задачи.
Если можно обойтись переопредилением формы
description = forms.CharField(min_length=20), то лучше воспользоваться им.
Если требуется проверить одно поле сложным образом, создайте для этого метод
clean_fieldname.
В случае необходимости использования нескольких полей одновременно
воспользуйтесь методом clean.
Комбинирование вариантов также допустимо.
---------------------------------------
Добавление страницы создания товара:

templates/product_edit.html

{% extends 'flatpages/default.html' %}

{% block content %}
<h1>Товар</h1>
<hr>
<form action="" method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <input type="submit" value="Save" />
</form>
{% endblock content %}
---------------
В HTML - форме указывали method="get", а для передачи информации, которая
изменяет состояие БД (создаёт, изменяет, удаляет данные), будем указывать
method="post".
В шаблон добавим тег {% csrf_token }, он нужен для безопасной отправки данных
и защиты от хакерских атак.
Подробнее здесь: https://ru.wikipedia.org/wiki/Межсайтовая_подделка_запроса
и здесь: https://docs.djangoproject.com/en/4.2/ref/csrf/
----------------
Теперь чтобы форма заработала нужно:
Создать представление- связать нашу форму и шаблон
Зарегистрировать представление в urlpatterns - Django должен знать,
    какое представление и по какому пути будет выполняться.

Добавим новое представление в views.py
simpleapp/views.py

from django.views.generic import ListView, DetailView, CreateView
from .models import Product
# -----------------
from django.http import HttpResponse
from .filters import ProductFilter
from django.urls import reverse_lazy
from .forms import ProductForm
..........
....
# Добавляем новое представление для создания товаров.
class ProductCreate(CreateView):
    # Указываем нашу разработанную форму
    form_class = ProductForm
    # модель товаров
    model = Product
    # и новый шаблон, в котором используется форма
    template_name = 'product_edit.html'
----------------
Зарегисрируем новое представление в urelpatterns.

simpleapp/urls.py

from django.urls import path
from .views import (ProductsList, ProductDetail, ProductsForm, ProductCreate)


urlpatterns = [
            # path - означает ПУТЬ
            # В данном случае путь ко всем товарам останется пустым
            # Т.к. объявленное представление является классом, а Django ожидает
            # функцию, надо представить этот класс в виде view.
            # Для этого вызываем метод as_view.
    path('', ProductsList.as_view(), name='product_list'),
            # pk - это первичный ключ товара, который будет выводиться у нас в шаблон
            # int - указывает на то, что принимаются только целочисленные значения

    path('<int:pk>', ProductDetail.as_view(), name='product_detail'),
    path('products_form/', ProductsForm.as_view()),
    path('create/', ProductCreate.as_view(), name='product_create'),
]
-----------------
Всё работает но есть нюанс.
Мы увидим форму но после её отправки, получим ошибку
"ImproperlyConfigured at /products/create/
No URL to redirect to.  Either provide a url or define a get_absolute_url method on the Model."

Проблема в том, что Django не знает, какую страницу нужно открыть после создания
товара. И как видно по описанию, можем убрать проблему, добавив метод
get_absolute_url в модель.

Добавим:
simpleapp/models.py

class Product(models.Model):
    name = models.CharField(max_length=50, unique=True)
    description = models.TextField()
    quantity = models.IntegerField(validators=[MinValueValidator(0)])
    # Поле которое будет ссылаться на модель категории
    category = models.ForeignKey(to='Category', on_delete=models.CASCADE,
                                 related_name='products')
    # все продукты в категории будут доступны через поле products
    price = models.FloatField(validators=[MinValueValidator(0.0)])

    def __str__(self):
        return f'{self.name.title()}: {self.description[:20]}'

    # Добавим absolute_urls

    def get_absolute_url(self):
        return reverse('product_detail', args=[str(self.id)])
-----------------------
Используем спец- функцию reverse, которая позволяет указывать не путь
вида /products/..., а название пути. Если вернуться к описанию путей в urls.py,
то увидим что мы добавили значения для аргументов name. Такой механизм обращения
удобен тем, что если мы захотим изменить пути, прийдётся вносить меньше
изменений в код, а значит, меньше вероятность пропустить какое-то место и
получить баг.

simpleapp/urls.py

rom django.urls import path
from .views import (ProductsList, ProductDetail, ProductsForm, ProductCreate)
urlpatterns = [
    # path - означает ПУТЬ
    # В данном случае путь ко всем товарам останется пустым
    # Т.к. объявленное представление является классом, а Django ожидает
    # функцию, надо представить этот класс в виде view.
    # Для этого вызываем метод as_view.
    path('', ProductsList.as_view(), name='product_list'),
    # pk - это первичный ключ товара, который будет выводиться у нас в шаблон
    # int - указывает на то, что принимаются только целочисленные значения
    path('<int:pk>', ProductDetail.as_view(), name='product_detail'),
    path('products_form/', ProductsForm.as_view()),
    path('create/', ProductCreate.as_view(), name='product_create'),
]
Здесь выводится название в таком же виде, как описано в методе __str__
в моделе Product.
GET и POST - запросы работают по-разному. Главное отличие заключается в способе
передачи данных.
Для передачи информации в GET-запросах используется query string,
а в POST- тело запроса.
---------------------------------------
Добавим страницу изменения информации о товаре. Мы можем использовать одну и
ту же форму и для создания, и для обнавления товара. И не только форму--
будем использовать тот же шаблон, хотя никто не запрещает зделать разные формы
и шаблоны. Единственное, что будет отличаться - дженерик,
который будем наследовать в представлении.

simpleapp/views.py
from django.views.generic import (
    ListView, DetailView, CreateView, UpdateView
)

# Добавляем представление для изменения товара.
class ProductUpdate(UpdateView):
    form_class = ProductForm
    model = Product
    template_name = 'product_edit.html'
------------------
И регистрируем представление в
simpleapp/urls.py

from .views import (
    ProductsList, ProductDetail, ProductsForm, ProductCreate, ProductUpdate
)
path('<int:pk>/update/', ProductUpdate.as_view(), name='product_update'),
--------------
http://127.0.0.1:8000/products/3/update/
---------------------------------------
Удаление товара:
Для подтверждения удаления сделаем отдельный шаблон.

templates/product_delete.html

{% extends 'flatpages/default.html' %}

{% block content %}
<h1>Удаление товара</h1>
    <hr>
    <form action="" method="post">
    {% csrf_token %}
    <p>Удаляем "{{ object.name }}"?</p>
    <input type="submit" value="Delete"/>
    </form>
{% endblock content %}
----------------
В views.py добавим представление, которое реализует удаление товара.
simpleapp/views.py

from django.views.generic import (
    ListView, DetailView, CreateView, UpdateView, DeleteView,
)
from .models import Product
# -----------------
from django.http import HttpResponse
from .filters import ProductFilter
from django.urls import reverse_lazy
from .forms import ProductForm

# Представление удаляющее товар.
class ProductDelete(DeleteView):
    model = Product
    template_name = 'product_delete.html'
    success_url = reverse_lazy('product_list')
----------------------
В представлении мы также не указывали фоорму.
В место неё появляется поле success_url, в которое мы должны указать, куда
перенаправить пользователя после успешного удаления товара.
Логика работы reverse_lazy точно такая же, как и у функции reverse,
которую использовали в моделе Product.
-----------------------
Регестрируем новый путь в urls.py с ProductDelete в качестве обработчика.
simpleapp/urls.py

from .views import (
    ProductsList, ProductDetail, ProductsForm, ProductCreate,
    ProductUpdate, ProductDelete,
)
 path('<int:pk>/delete/', ProductDelete.as_view(), name='product_delete'),
---------------------------------------
Дженерики требуют указание формы в классе:
CreateView - нужно сообщить Django, как сохранять передаваемые данные.
UpdateView - нужно собщать Django, как сохранять передаваемые изменения
в объекте БД.
-------------
Какие существуют подходы для валидации данных в формах?
clean - Можем переопределить метод и написать свои сложные проверки.
Описание полей формы с указанием ограничений в полях формы.
---------------------------------------
Для вывода поля фильтрации по датам понадобиться указать спец-тип в HTML
https://developer.mozilla.org/ru/docs/Web/HTML/Element/input/datetime-local
-----
Необходимо изучить информацию по следующим ссылкам и
постараться реализовать выбор даты.
Посмотрите как указан фильтр name:
https://django-filter.readthedocs.io/en/stable/guide/usage.html#the-filter

Вам потребуется дополнительно указать правельный тип поля формы в атрибуте widget.
Пример тут:
https://django-filter.readthedocs.io/en/stable/ref/widgets.html
===============================================================================

D_5

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---------------------------------------
ИДЕНТИФИКАЦИЯ
Предоставление каких либо данных, которые могут сопоставить с БД
идентификаторов пользователей.
В качестве идентификаторов могут выступать:
• логин - строка, как правило, состоящая из латинских символов
• адрес лектрон-почты
• номер телефона
• числовой идентификатор (USER ID, оторый иногда обозначают как UID)
• номер банковской кары
• персональные данные другого рода ( номер СНИЛС )
Идентификация пользователя призвана спросить у пользователя: "Кто ты?"
Как только пользователь, используя различные виды идентификаторов, ответил
на этот вопрос, ситема проверяет наличие такого идентификатора в БД и,
в случа успеха, начинается следующий этап - аутентификация.
Соврименные информационные системы часто предоставляют несколько способов
идентификации. Например ГосУслуги ( по номеру телефона, электронной почты
 или СНИЛС )
---------------------------------------
Аутентификация
После того как сервис удостоверился, что пользователь с таким идентификатором
существует, он должен проверить действительно ли вы тот пользователь.
Различают четыре фактора аутенификации:
1. Нечто. ИЗВЕСТНОЕ пользователю. ( pin- код, одноразовые и многоразовые пароли,
    секретные слова, графические ключи, криптографические ключи)
2. Нечто. ИМЕЮЩЕЕСЯ у пользователя. Различные устройства, позволяющие
    подтвердить подлинность данных входа. ( смарт-карты,usb-токены)
3. Нечто. ПРЕСУЩЕЕ пользователю. К этой категории данных относят различного вида
    биометрику. (отпечатки пальцев, сканеры лица, сканеры сетчатки глаза,
    голос и рукописная подпись)
4. Нечто. АСОЦИИРОВАННОЕ с пользователем. Например, GPS-координаты устройства,с
    которого осуществляется вход. Естественно, что этот фактор аутентификации
    не может быть самостоятельным. Однако он может служить дополнительной
    проверкой на этапе аутенфикации.

Часто бывает, что этапы идентификации и аутентификации происходят паралельно-
 как минимум для пользователя. Однако это происходит не всегда, иногда
 сервис просит сначала ввести логин и только потом пароль.
---------------------------------------
Немного о паролях
1. Одноразовые ( пароли из СМС ) которые нужно ввести в опредилённый промежуток
    времени.
2. Многоразовые. Например: для входа достаточно ввести номер телефона, к которому
привязан аккаунт, а также одноразовый пароль, который приходит из официального
    бота (в случае если аккаунт уже авторизован на каком-то устройстве).
---------------------------------------
Многофакторная аутентификация
Часто требуется использование нескольких видов аутентификаций.
1. Пользователь вводит известную ему пару: почта-пароль.
2. Система перенаправляет на страницу ожидания и отображает текст: "Уведомление
    отправлено на устройство__. Чтобы подтвердить свою личность, нажмите ДА в
    уведомлении".
3. Паралельно на телефон, на котором данный аккаунт уже авторизован, приходит
    уведомление о том, что некий пользователь пытается войти в аккаунт с другого
    устойства. В этом уведомлении указывается, с какого устройства и откуда
    пытаются войти в аккаунт. А также есть две кнопки "разрешить войти" и
    "запретить".
4. Если на телефоне было выранно "разрешить войти", пользователь получает
    доступ к сервисам с другого устройства - процес аутентификации завершается.
---------------------------------------
САРТСНА
Отдельно стоит сказать про ещё один фактор безопасности- капча (англ. CAPTCHA)
Полность автоматизированный публичный тест Тьюринга для различия компьютеров
 и людей. (картинка с сфетофорами)
---------------------------------------
Авторизация
После успешной аутентификации пользователь может работать с сайтом ли преложением.
В зависимости от уравня прав, который сервис предоставляет пользователю с данным
идентификатором, пользователь получает доступ к отдельным частям веб-приложения.

Авторизация производит контроль доступа к различным ресурсам системы в процессе
работы пользователей. Получается, авторизация без пройденной заранее аутентификации
не имеет смысла.
Возможно вы встречались с ситуацией, когда при попытке попасть на какую-то
страницу,сайт вас уведомляет, что данная страница доступна только для авторизованных
пользователей (ошибка 401) или у вас не достаточно прав для просмотра данной
страницы (ошибка 403).

401 код ошибки говорит о том, что предоставленные данные аутентификации по
    какой-либо причине были отклонены сервером или донные аутентификации вообще
    небыли переданы серверу.
403 код ошибки говорит о том,что у пользователя нет доступа к запрашиваемому
    ресурсу. Тоесть сервер как бы говорит: "Я знаю кто вы. о у вас нет прав для
    доступа к данному ресурсу. Возможно вам нужно обратиться к админу ресурса
    за получением разрешений". Повторно клиент не должен посылать запросы на
    этот ресурс. Для другог пользователя этот ресурс может быть доступен.
---------------------------------------
OAuth
1. Менеджеры паролей. Например: 1Password или Bitwarden. Но при их использовании
    возникает вопрос доверия разработчикам этих продуктов.
2. Аутентификация и авторизация на сервисе-клиенте с помощью сервиса-провайдера.
    Вам предлагается или заполнить форму регистрации, или зарегистрироваться
    припомощи других сервисов. Именно этот механизм называется OAuth.
Он предлагает более широкие возможности - например, если авторизовать (предоставить
опредилённые права) сервис-клиен на сервесе-провайдере, то новый сайт сможет
выполнять на основном аккаунте разрешённые действия без участия пользователя.
Например: Какие именно действия сможет выполнять сайт, скажет сам провайдер OAuth.
    "что сайт получит доступ к почте, информации о профиле и к управлению
    контактами"

Если мы регистрируемся с помощью сервиса1 в сервисе2, то сервис2 получит доступ
к опредилённым действиям в сервисе1 (публиковать статьи, просматривать список
друзей, редактировать документы).

Существует несколько протоколов, призванных выполнить схожие задачи - OpenID,
а также OAuth 1.0 и OAuth 2.0.

OpenID - призван только для аутентификации пользователя на стороне-клиенте с
    помощью аккаунта-провайдера.
Протоколы OAuth 1.0 и OAuth 2.0 - также позволяют осуществить авторизацию клиента
    на стороне провайдера - выполнять действия на аккаунте-провайдере с
    помощью клиентского веб-приложения.
---------------------------------------
Cookie
Браузер(клиент) и сервер общаются друг с другом посредством протокола HTTP
и его методов - GET, POST и других. Этот протокол является stateless - каждый
запрос действует независимо от других. Тем самым текущее состояние клиента
с точки зрения протокола HTTP никак не хранится на сервере.
Пример:
Доустим вы вошли на сайт. Пусть это будет интернет магазин, на котором вы
закинули в корзину товары, а оплату решили отлложить(вдруг ещё что-то захочется
купить). Закрыв сайт, вы прервали общение браузера и сервера. При следующей
попытке входа на сайт, вообще говоря, браузер и сервер вновь должны "познакомиться"
И корзина должна быть пустой. Однако на современных сайта вы обнаружите, что
корзина уже не пустая.
Одно дело, если бы вы авторизовались, и позиции в корзине асоциировались с вашим
аккаунтом, но совсем другое дело, когда вы не даёте серверу ничего.
Или всё-таки отдаёте?
------------------
В силу отсутствия встроенного хранения состояния в протоколе HTTP, релизовали
хранение инормации cookie (куки, англ.-печенье)

Cookie - это информация, которую хранит браузер по просьбе сервера веб-приложения.

В таком случае, браузер при отправке зпроса на сервер, может вновь отправить
cookie с какой-то пользовательской информацией. Хранить конфиденциальную информацию
в cookie небезопасно. Проблема в том, что эта информация передаётся в виде
чистого текста, и сама по себе не является защищённой. Поэтому cookie чаще всего
используют для хранения идентификаторов, которые нельзя подобрать, или информации
которая не требует безопасного использования.
---------------------------------------
Сессии
Это более безопасный механизм. Отличие сессии от чистого использования cookie
в том, что реальная информация хранится на сервере приложения, а в самих cookie
хранится только идентификатор сессии.
Идентификатор суссии и информация на сервере- это как номер заказа и сами
товары в заказа. С номером заказа (идентификатором сессии) вы приходите в магазин
(на сервер) и получаете товары (информацию от сервера).

Механизм сессии должен быть реализован разработчиком самостоятельно, т.е. он не
является встроенным механизмом, предоставляет протокол передачи данных (HTTP
или другие). Получается, что от разроботчика зависит на сколько безопасно и
качественно он реализует тот механизм.

Django - для работы с сессиями существует "решение из коробки". Этот модуль
аввтоматически подключается к каждому поректу.

settings.py
INSTALLED_APPS = [
    ... ,
    'django.contrib.sessions',
    ...
    ]
MIDDLEWARE = [
    ... ,
    'django.contrib.sessions.middleware.SessionMiddleware',
    ]
Данное приложение выполняет эту задачу - управление сессиями.
В обработке каждого запроса (переменная request) вы можете получить доступ к
данным сессии (которые храняться на сервере) и каким-то образом манипулировать ими.
Рассмотрим, как в общем виде происходит процес обмена данными между браузером
и сервером в случае наличия сессии.

Процесс прохождения запроса по мидлваре сессии и аутентификации с последующей
выдачей ответа из приложения:
1. При отправке запроса (request) на сервер, браузер с помощью cookie отправляет
    идентификатор сессии.
2. Сервер считывает этот идентификатор и смотрит в базе в таблице django-session
    его наличие.
3. Если сессия, согласно БД, является активной, пользователь автоматически
    проходит процедуру аутентификации, получая доступ к функциям приложения.
4. В зависимости от результата авторизации сервер обрабатывает запрос (внутри
    представления view), при необходимости сохраняя данные в сессии.
5. После чего формируется ответ сервера (response), в котором помимо прочего
    вновь отправляется идентификатор сессии, если это необходимо.
---------------------------------------
Дополнительный механизм безопасности работы с сессиями.

На некоторых сайтах, в настройках безопасности, можно найти список активных
сессий этого аккаунта. В этом списке можно увидеть устройство(браузер,десктопное
или мобильное приложение), дату последнего входа и другие данные.
При необходимости можно завершить одну или все сессии сразу. Это очень удобный
механизм защит, если вы например зашли в VK не со своего компьютера, но забыли
"выйти"(авершить сессию). Заходя через другое устройство, вы можетезакрыть
эту сессию.
---------------------------------------
Ограничение доступа к страницам

Как и в случае управления сессиями, в Django поддержка авторизации реализуется
в виде приложения, автоматически подключаемого к каждому новому проекту.
INSTALLED_APPS = [

    'django.contrib.auth',
    ]
Приложение django.contrib.auth предоставляет два решения для предоставления
доступа к представлениям только для зарегистрированных пользователей.
• декоратор login_required
• миксин LoginRequiredMixin
---------------------
Декоратор login_required

Содержится в пакете django.contrib.auth.decorators
Декоратор рекомендуется использовать для функций-представлений.

from django.contrib.auth.decorators import login_required

@login_required
def show_proteced_page(request):
    // do something protected

Представление в виде функции мы реализовывали в модуле D_4, юнит 3.
https://docs.djangoproject.com/en/4.0/topics/http/views/
---------------------------------------
Миксин LoginRequiredMixin
Использовать миксин LoginRequiredMixin также просто: его необходимо добавить
в список наследуемых класов при создании представления.
Добавил в класс!!!!!!!!!!!!!!!!!!!!!!!!!!!!
simpleapp/view.py
from django.contrib.auth.mixins import LoginRequiredMixin

class ProductCreate(LoginRequiredMixin, CreateView):
    form_class = ProductForm
    model = Product
    template_name = 'product_edit.html'
----------------
А что произойдёт, когда страницу откроет не аутентифицированный пользователь?

Если представление использует миксин LoginRequiredMixin, все запросы не
аутентифицированных пользователей будут перенаправлены на страницу входа, или
будут показаны ошибки HTTP 403 Forbidden, в зависимости от параметра raise_exception.
 Параметр raise_exception мы не добавляли.
 И страница входа, которая например должна быть указана в settings.py в переменной
LOGIN_URL, тоже не указана в нашем проекте.
Если мы попробуем открыть страницу (product/create) то получим ошибку 404, а
в строке запроса у нас будет
http://127.0.0.1:8000/accounts/login/?next=/products/create/
Видим что страница "/accounts/login/" не найдена. Оказывается страница входа
имеет значение по умолчанию.
Подробнее здесь:
https://docs.djangoproject.com/en/4.0/ref/settings/
LOGOUT_REDIRECT_URL
PASSWORD_RESET_TIMEOUT
---------------------------------------
Ошибка 403

Настроим выдачу ошибки с кодом 403, для не авторизованных пользователей, которые
будут заходить на страницу создания товара.

simpleapp/view.py

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------

---------------------------------------




